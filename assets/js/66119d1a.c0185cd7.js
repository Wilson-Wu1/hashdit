"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4900],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(a),u=i,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||r;return a?n.createElement(m,o(o({ref:t},p),{},{components:a})):n.createElement(m,o({ref:t},p))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},4538:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=a(87462),i=(a(67294),a(3905));const r={slug:"monthly-incident-sharing-apr-2024",title:"Monthly Incident Sharing - April 2024",authors:["Sebastian"],tags:["Apr","Incidents","Sharing",2024]},o=void 0,s={permalink:"/hashdit/blog/monthly-incident-sharing-apr-2024",source:"@site/blog/2024-05-14/2024-05-14.md",title:"Monthly Incident Sharing - April 2024",description:"Introduction",date:"2024-05-14T00:00:00.000Z",formattedDate:"May 14, 2024",tags:[{label:"Apr",permalink:"/hashdit/blog/tags/apr"},{label:"Incidents",permalink:"/hashdit/blog/tags/incidents"},{label:"Sharing",permalink:"/hashdit/blog/tags/sharing"},{label:"2024",permalink:"/hashdit/blog/tags/2024"}],readingTime:6.085,hasTruncateMarker:!1,authors:[{name:"Sebastian Lim",title:"SCS@HashDit",url:"https://github.com/slim115",imageURL:"https://github.com/slim115.png",key:"Sebastian"}],frontMatter:{slug:"monthly-incident-sharing-apr-2024",title:"Monthly Incident Sharing - April 2024",authors:["Sebastian"],tags:["Apr","Incidents","Sharing","2024"]},prevItem:{title:"Getting Started with HashDit Snaps - A Step-by-Step Guide",permalink:"/hashdit/blog/hashdit-snaps-guide"},nextItem:{title:"Monthly Incident Sharing - March 2024",permalink:"/hashdit/blog/monthly-incident-sharing-mar-2024"}},l={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"Top 5 DApps incidents",id:"top-5-dapps-incidents",level:2},{value:"XBridge - $1.03m - Wrong Proxy Upgrade",id:"xbridge---103m---wrong-proxy-upgrade",level:3},{value:"FinanceChainge - $710k - Lack of Validation",id:"financechainge---710k---lack-of-validation",level:3},{value:"OpenLeverage - $226k - Internal accounting",id:"openleverage---226k---internal-accounting",level:3},{value:"NGFS - $190k - Lack of Validation",id:"ngfs---190k---lack-of-validation",level:3},{value:"ATM - $180k - Price Manipulation",id:"atm---180k---price-manipulation",level:3},{value:"Key lessons for developers",id:"key-lessons-for-developers",level:2}],p={toc:c};function d(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("div",{align:"justify"},(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"In this monthly series, HashDit is sharing the monthly security incidents in the crypto space and what we can learn from them. For this Apr 2024 edition, the total losses mounted up to $2.7 million, showing a 54% decrease compared to April 2023. "),(0,i.kt)("p",null,"In this sharing, we focus on the DApps incidents. Below are the top 5 DApps incidents that DApp Developers should pay attention to."),(0,i.kt)("h2",{id:"top-5-dapps-incidents"},"Top 5 DApps incidents"),(0,i.kt)("h3",{id:"xbridge---103m---wrong-proxy-upgrade"},"XBridge - $1.03m - Wrong Proxy Upgrade"),(0,i.kt)("p",null,"XBridge is a Bridge / Cross-Chain protocol that allows users to bridge funds from one chain to another. In this attack, a vulnerable logic contract was introduced in a proxy contract upgrade, allowing the attacker to drain 466,490,205 STC tokens, 511,424,527 SRLTY tokens and 11,165,018 Mazi tokens, amounting to ~$1.03m. Interestingly, the attacker did not liquidate all tokens, and only swapped ~$192k to BNB and deposited it into Tornado Cash, leaving some tokens in his wallet."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root cause"),": The listToken function in the target contract does not verify msg.sender and _tokenOwner. Essentially, as long as _baseToken==_correspondingToken, the attacker can set the key variable _tokenOwner to msg.sender which is himself, and subsequently call withdrawTokens to extract the baseToken funds directly."),(0,i.kt)("p",null,"The upgrade introduced a wrong mapping _tokenOwner instead of using TokenOwner (which was correctly set up in the old logic contract), anyone can thus assume _tokenOwner and withdraw tokens."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Onchain information"),":"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://bscscan.com/tx/0x26b1c65526a0d932c1e5589e1ec31341cf918e77247ef49d3036810c0cbb09ad"},"Bug introduced in Upgrade tx")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://bscscan.com/tx/0xcf8aa3b9dfcf9250a5da5e9571f98374f1d649024a81b8d5f7da2f7d92f313f9"},"Hack tx")),(0,i.kt)("p",null,"Code snippet:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"IMG-1",src:a(89121).Z,width:"1302",height:"1328"})),(0,i.kt)("h3",{id:"financechainge---710k---lack-of-validation"},"FinanceChainge - $710k - Lack of Validation"),(0,i.kt)("p",null,"FinanceChainge is a DeFi protocol, which is known as a liquid cross-chain aggregator. In this attack, the hackers exploited the swap function with a malicious payload. The hack amount is ~ $710k. Interestingly, the sole victim is 0x8a4aa176007196d48d39c89402d3753c39ae64c1, which is linked to the project team and hence likely funds belonging to the project."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root cause"),": The swap() function had a bug which allowed hackers to exploit users\u2019 allowance given to this victim contract."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Onchain information"),":"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://bscscan.com/tx/0xd348b5fc00b26fc1457b70d02f9cb5e5a66a564cc4eba2136a473866a47dac08"},"Hack tx 1")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://bscscan.com/tx/0x051276afa96f2a2bd2ac224339793d82f6076f76ffa8d1b9e6febd49a4ec11b2"},"Hack tx 2")),(0,i.kt)("p",null,"Code snippet:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"IMG-2",src:a(97186).Z,width:"960",height:"1182"})),(0,i.kt)("h3",{id:"openleverage---226k---internal-accounting"},"OpenLeverage - $226k - Internal accounting"),(0,i.kt)("p",null,"OpenLeverage is a DeFi protocol which operates as a DEX, allowing users to swap tokens. In this rather complicated attack, the attacker was able to compromise the OpenLev contract on BSC. The exploit consisted of a sequence of arbitrary external calls, taking advantage of inconsistency in the accounting for borrowers."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root cause"),": The attack occurred due to a discrepancy in the accounting process, which comprised two separate transactions. "),(0,i.kt)("p",null,'Firstly, the attacker set up a "margin position" in the OpenLevV1 contract using the marginTrade function. This function call permitted an additional position creation with minimal collateral through an untrusted external call to the OpBorrowing contract. This position was ultimately liquidated. '),(0,i.kt)("p",null,"However, both OpenLevV1 and OpBorrowing contracts use the LToken contract for their transactions. Consequently, the debt of the margin position was unintentionally cleared in the liquidation process. "),(0,i.kt)("p",null,"In the second transaction, the attacker exploited this situation. They used the payoffTrade function, bypassing the health check, and drained all the collateral from the margin positions."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Onchain information"),":"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://bscscan.com/tx/0xf08b6d36dc6f650c030344b6307ae94528f77a01db11d1284ed966e7e44337d3"},"Hack tx 1")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://bscscan.com/tx/0x0434bf08a63d70b84fad033d38d8b645498016b3931af4d13f6c11e86848876b"},"Hack tx 2")),(0,i.kt)("p",null,"Code snippet:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"IMG-3",src:a(69646).Z,width:"1302",height:"734"}),"\n",(0,i.kt)("img",{alt:"IMG-4",src:a(6809).Z,width:"1302",height:"820"})),(0,i.kt)("h3",{id:"ngfs---190k---lack-of-validation"},"NGFS - $190k - Lack of Validation"),(0,i.kt)("p",null,"NGFS is a DeFi token on BSC. In this attack, the attacker was able to manipulate his own token balance due to a lack of validation for a privileged function. As such, he could simply increase his balance and dump the tokens on the open market."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root cause"),": The function delegateCallReserves() can be called only once, and is supposed to be set up during the initialization phase, however it was left untouched. As such, anyone could assume _uniswapV2Proxy position and then call the setProxySync() method to set an arbitrary _uniswapV2Library. Lastly, within the reserveMultiSync() function, the attacker could set a large balance for himself since he has _uniswapV2Library privilege."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Onchain information"),":"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://bscscan.com/tx/0x8ff764dde572928c353716358e271638fa05af54be69f043df72ad9ad054de25"},"Hack tx")),(0,i.kt)("p",null,"Code snippet:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"IMG-5",src:a(94860).Z,width:"1260",height:"1010"})),(0,i.kt)("h3",{id:"atm---180k---price-manipulation"},"ATM - $180k - Price Manipulation"),(0,i.kt)("p",null,"ATM is a DeFi token on BSC. In this attack, the attacker was able to make use of the funds in the ATM contract to add liquidity to the pool. At the same time, he could invoke the skim function to drain excess funds from the pair."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root cause"),": The _transfer routine can be exploited by directly transferring funds to the pair contract. This triggers the distributeCurrency function, adding liquidity from the perspective of the ATM contract. The attacker could then profit by simply calling skim on the pair."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Onchain information"),":"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://bscscan.com/tx/0x458ea2d7e6c5953b0d927aabc1c6a144df276d6ffa55b236087763396ee57067"},"Hack tx 1")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://bscscan.com/tx/0xee10553c26742bec9a4761fd717642d19012bab1704cbced048425070ee21a8a"},"Hack tx 2")),(0,i.kt)("p",null,"Code snippet:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"IMG-6",src:a(57038).Z,width:"1112",height:"1158"})),(0,i.kt)("h2",{id:"key-lessons-for-developers"},"Key lessons for developers"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Input validation is a crucial process - it's essential to verify all potential user inputs, especially when these inputs affect changes to the state of the system. This holds particularly true in the below scenarios:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Calldata Parameters:")," Given that attackers have the ability to craft any data, extra validation steps must be in place for calldata parameters.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"User Approvals:")," During the process where the protocol contract manages users' approvals, meticulous input checks are paramount to prevent potential malicious activities.")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"To guard against price manipulation, it's essential to ensure that updated prices cannot be influenced to reflect unexpected values. Oracles, both on-chain and off-chain types, can be employed by developers. Here's how:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Set Boundaries:")," Implementing limits can block prices from being abruptly manipulated to an impossible value, regardless of the oracle type in use.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Fallback Oracle:")," Integrate a secondary oracle as a fallback measure. This ensures that if the initial oracle fails, there is a backup in place to verify the consistency of prices. By doing so, it ensures continuous, reliable price feeds, and safeguards against single point of failure.")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Upgrading proxy code should be taken very seriously and should require several checks such as:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Thorough Testing"),": Conduct rigorous testing before deploying any updates to ensure that the changes will not disrupt existing functionalities or introduce new vulnerabilities.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Code Audits"),": Always get your code audited by a third party. It's crucial to have another set of eyes inspect your code, as they may spot issues that you've overlooked.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Pause Functionality"),": Make sure that your contract has a 'pause' functionality. In case something goes wrong, this function allows halting the operations until the issue is fixed.")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Addressing internal accounting errors and effectively handling external arbitrary calls are critical for crypto developers, especially for lending projects which involve complex financial transactions. Here are some recommendations:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Sequencing Transactions"),": Consider sequencing transactions appropriately. Generally, it's safer to make state changes before conducting external calls.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"External Calls"),": Be extremely careful while interacting with third-party contracts. They should be treated as potentially malicious. Avoid state changes after making a call to an external contract.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Precise Accounting"),": Keep accurate and precise accounting to make sure all balances tally at the end of each operation. This is primarily to ensure that no tokens are lost or mistakenly created during transactions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Debt and Collateral Management"),": Carefully track and manage computational handling of debt and collateral. Errors in management or calculation can lead to vulnerabilities such as unforeseen liquidations or insolvency.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Limit Permissions"),": Limit the permissions of the contract that makes external calls to only what's necessary to reduce your contract's attack surface."))))),(0,i.kt)("p",null,"Feel free to contact us at ",(0,i.kt)("a",{parentName:"p",href:"mailto:support@hashdit.io"},"support@hashdit.io")," for any support needed! Stay safe!")))}d.isMDXComponent=!0},89121:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/1-a49b6e7bdafe035e7269f604fc05f2c5.png"},97186:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/2-8050db9e770d0b9bc69fc9e2b8fdc6b8.png"},69646:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/3-ceac19bc84d78f73b52ec8694e1ef8c1.png"},6809:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/4-2a96f75182efb00fbd548a43bb174d6f.png"},94860:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/5-3c256dc651a0b813d3338eddf738c0e7.png"},57038:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/6-d3a3ebc82aa15b51bf05481314118f56.png"}}]);